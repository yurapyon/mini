built in
  console read/emit
devices
  screen
  audio
  terminal ui
  keyboard
  mouse

terminal drawing / pixel graphics would be nice

all io could be in terms of 'devices'
  this means
    you dont need externals for io
    you can check device capabilites easily
    you dont need to define builtins for io, can just have a general get/set

take some ideas from colorForth
  "dictionary only records 32 bits of identifier"
    shannon/huffman coding
    complicates things and doesnt save a ton of space
      could also just use 6bits per character, this is 64 different options
  code must be in fixed sized blocks
  editor ?
    could do it on the web?
    or love 2d or something

for colorForth words
  00------*-------*-------
  ^ ^     ^       ^
  | 6bit  8bit    8bit
  tag
  for every word youre restricted on the first letter
  3 bit tag with 5bit char means 32 options
  could restrict it so words can only start with a-z

a very short global circular queue could be useful ( ? )

should be good for
  web (TS or webasm)
  microcontroller
  zig

should mini be a whole forth system including an editor?
  this makes it harder to write but the editor could be written in mini
    and included in the base file
  no reading from stdin or running scripts
  would need disk i/o
  need screen/console i/o

===

input line buffer
basic most used stack manipulation words
small cells

byte based (?)

memory indexed from zero

hex and decimal numbers

===

builtins can be bytecodes

bytecodes gives you 256 builtins

there can be a bytecode like
#ext sizeof(OS pointer)
for external function calls

atmega program memory is 2bytes (12 bits up to 0x3fff)

===

if builtins are 0-127
and compiled words are 0xC.......

then defining core words as deriving from builtins takes up more space
  than just having it as a builtin
  ie
  <= builtin takes less space even though it could be defined as
  : <= > 0= ;

but also want to balance 'ease of implementing vm' with 'core code reusability'

===

dictionary

definition names can be encoded
  if shannon encoding from colorforth is an example,
  you can fit names 12 chars long in 8 bytes

with untyped, all words have a dictionary entry, even builtins
mini doesnt need that

===

interactivity

bye & quit should be implemented

===

console drawing or display would be nice
could be external functions

===

should be able to interpret itself
  used for
    including files
    executing xts
  words needed
    execute

===

all bytecode <= 127

bytecode 0-------0-------
miniword 1-------*-------

( _
  0 enum `nop

    enum `lit
    enum `exit
    enum `define
    enum `bye

    enum `word

    enum `dup
    enum `drop
    enum `swap
    enum `over
    enum `flip
    enum `rot
    enum `-rot

    enum `c!
    enum `c@
    enum `c,

    enum `!
    enum `@
    enum `,

    enum `char

    enum `+
    enum `-
    enum `*
    enum `/mod

    enum `>r
    enum `r>
    enum `r@

    enum `=
    enum `0=
    enum `<
    enum `<=
    enum `>
    enum `>=

    enum `and
    enum `or
    enum `xor
    enum `invert
    enum `lshift
    enum `rshift

    enum `move
    enum `mem=

    enum `here
    enum `latest

    enum `state
    enum `]
    enum `[

    enum `define

    enum `jump
    enum `branch
    enum `branch0

    enum `emit

    enum `make-immediate
    enum `make-hidden

    enum `ext
constant bytecode-ct
)

read from stdin
          repl
          including files
